{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto'),\n      Script = require('./script'),\n      Multisig = require('./multisig'),\n      Encoder = require('./encoder'),\n      Output = require('./output'),\n      Constants = require('./constants'),\n      networks = require('./networks');\n\nclass Transaction {\n  constructor() {\n    this.version = 4;\n    this.inputs = [];\n    this.outputs = [];\n    this.lock_time = 0;\n  }\n\n  clone() {\n    let tx = new Transaction();\n    tx.version = this.version;\n    this.inputs.forEach(input => {\n      tx.addInput(input.previous_output.address, input.previous_output.hash, input.previous_output.index, input.previous_output.script);\n    });\n    tx.outputs = JSON.parse(JSON.stringify(this.outputs));\n    return tx;\n  }\n\n  addInput(previous_output_address, previous_output_hash, previous_output_index, previous_output_script) {\n    const input = {\n      \"address\": previous_output_address,\n      \"previous_output\": {\n        \"address\": previous_output_address,\n        \"hash\": previous_output_hash,\n        \"script\": previous_output_script,\n        \"index\": previous_output_index\n      },\n      \"script\": \"\",\n      \"sequence\": 4294967295\n    };\n\n    if (Script.isStakeLock(input.previous_output.script)) {\n      input.sequence = Script.fromASM(input.previous_output.script).getLockLength();\n    }\n\n    this.inputs.push(input);\n  }\n\n  addMessage(address, message) {\n    var output = new Output().setMessage(address, message);\n    this.outputs.push(output);\n    return output;\n  }\n\n  addOutput(address, symbol, value, to_did) {\n    let output = symbol === 'ETP' ? this.addETPOutput(address, value, to_did) : this.addMSTOutput(address, symbol, value, to_did);\n\n    if (Multisig.isMultisigAddress(address)) {\n      if (to_did) throw Error('Digital identity incompatible with P2SH');\n      output.setP2SH();\n    }\n\n    return output;\n  }\n\n  addETPOutput(address, value, to_did) {\n    var output = new Output();\n    output.setTransfer(address, value);\n    if (to_did) output.specifyDid(to_did, \"\");\n    this.outputs.push(output);\n    return output;\n  }\n\n  addMSTOutput(address, symbol, value, to_did) {\n    var output = new Output();\n    output.setAssetTransfer(address, symbol, value);\n    if (to_did) output.specifyDid(to_did, \"\");\n    this.outputs.push(output);\n    return output;\n  }\n\n  addLockedAssetOutput(recipient_address, recipient_avatar, symbol, quantity, attenuation_model, height_delta, from_tx, from_index) {\n    return this.addMSTOutput(recipient_address, symbol, quantity, recipient_avatar).setAttenuation(attenuation_model, height_delta, from_tx, from_index);\n  }\n\n  addAssetIssueOutput(symbol, max_supply, precision, issuer, address, description, secondaryissue_threshold, is_secondaryissue, issue_to_did) {\n    if (!/^([A-Z0-9\\.]{3,63})$/.test(symbol)) throw Error('ERR_SYMBOL_NAME');else if (!/^([A-Za-z0-9\\.@_-]{3,63})$/.test(issuer)) throw Error('ERR_ISSUER_NAME');else if (max_supply <= 0) throw Error('ERR_MAX_SUPPLY_TOO_LOW');else if (precision < 0) throw Error('ERR_PRECISION_NEGATIVE');else if (precision >= 20) throw Error('ERR_PRECISION_TOO_HIGH');else if (description.length >= 64) throw Error('ERR_DESCRIPTION_TOO_LONG');else if (!isAddress(address)) throw Error('ERR_ADDRESS_FORMAT');else if (!(secondaryissue_threshold >= -1 || secondaryissue_threshold <= 100)) throw Error('ERR_SECONDARYISSUE_THRESHOLD_OUT_OF_RANGE');else {\n      let output = new Output().setAssetIssue(symbol, max_supply, precision, issuer, address, description, secondaryissue_threshold, is_secondaryissue);\n\n      if (issue_to_did) {\n        output.specifyDid(issuer, '');\n      }\n\n      this.outputs.push(output);\n      return output;\n    }\n  }\n\n  addCertOutput(symbol, owner, address, cert, status, content) {\n    let output = new Output();\n    output.specifyDid(owner, \"\");\n    this.outputs.push(output.setCert(symbol, owner, address, cert, status, content));\n    return output;\n  }\n\n  addDidIssueOutput(address, symbol, did_address) {\n    var output = new Output();\n    this.outputs.push(output.setIdentityIssue(address, symbol, did_address));\n    return output;\n  }\n\n  addMITRegisterOutput(address, symbol, content) {\n    var output = new Output();\n    this.outputs.push(output.setMITRegister(address, symbol, content));\n    return output;\n  }\n\n  addMITTransferOutput(address, symbol) {\n    var output = new Output();\n    this.outputs.push(output.setMITTransfer(address, symbol));\n    return output;\n  }\n\n  addDidTransferOutput(address, symbol) {\n    var output = new Output();\n    this.outputs.push(output.setIdentityTransfer(address, symbol));\n    return output;\n  }\n  /**\n   * Add ETP deposit lock output\n   * \n   * @deprecated ETP deposit has been deactivated by supernova hardfork\n   * \n   * @param {} address \n   * @param {*} value \n   * @param {*} locktime \n   * @param {*} network \n   */\n\n\n  addLockOutput(address, value, locktime, network) {\n    if (network == undefined) network = networks['mainnet'];else if (typeof network === 'string' && networks[network]) network = networks[network];\n    locktime = parseInt(locktime);\n\n    if (network.locktimes.indexOf(locktime) !== -1) {\n      var output = new Output();\n      this.outputs.push(output.setDeposit(address, value, locktime));\n      return output;\n    } else {\n      throw Error('Illegal locktime');\n    }\n  }\n\n  clearInputScripts() {\n    this.inputs.forEach(input => {\n      input.script = [];\n    });\n    return this;\n  }\n\n  encode(add_address_to_previous_output_index) {\n    return Encoder.encodeTransaction(this, add_address_to_previous_output_index);\n  }\n\n  static decode(rawtx, network) {\n    return Encoder.decodeTransaction(new Transaction(), rawtx, network);\n  }\n\n  static calculateTxid(rawtx, reverse = true) {\n    return reverse ? hash256(Buffer.from(rawtx, 'hex')).reverse() : hash256(Buffer.from(rawtx, 'hex'));\n  }\n\n}\n\nfunction sha256(buffer) {\n  return crypto.createHash('sha256').update(buffer).digest();\n}\n\nfunction hash256(buffer) {\n  return sha256(sha256(buffer));\n}\n\nfunction isAddress(address) {\n  return address.length == 34 && (address.charAt(0) == 'M' || address.charAt(0) == 't' || address.charAt(0) == '3');\n}\n\n;\nmodule.exports = Transaction;","map":null,"metadata":{},"sourceType":"script"}