{"ast":null,"code":"'use strict';\n\nvar bip39 = require('bip39');\n\nvar bitcoin = require('bitcoinjs-lib');\n\nvar Networks = require('./networks.js');\n\nvar Transaction = require('./transaction.js');\n\nvar Script = require('./script.js');\n\nvar Message = require('./message.js');\n\nconst DEFAULT_KEY_SEARCH_DEPTH = 250;\nconst MNEMONIC_SIZE = 256;\n\nclass Wallet {\n  constructor() {\n    this.rootnode = null;\n  }\n  /**\n   * Generate a new mnemonic.\n   * @return {Promise.String}\n   */\n\n\n  static generateMnemonic(wordlist) {\n    return Promise.resolve(bip39.generateMnemonic(MNEMONIC_SIZE, wordlist));\n  }\n\n  /**\n   * Generates a new wallet from the given seed.\n   * @param {Buffer} seed\n   * @param {network} network (optional)\n   * @return {Promise.Wallet}\n   */\n  static fromSeed(seed, network) {\n    return Promise.resolve().then(() => {\n      let wallet = new Wallet();\n      wallet.rootnode = bitcoin.HDNode.fromSeedBuffer(seed, network);\n      return wallet;\n    });\n  }\n\n  /**\n   * Generates a new wallet from the given mnemonic.\n   * @param {String} mnemonic Menmonic words\n   * @param {network} network (optional)\n   * @return {Promise.Wallet}\n   */\n  static fromMnemonic(mnemonic, network = 'mainnet') {\n    if (Networks[network] == undefined) throw \"illegal network\";\n    return Wallet.mnemonicToSeed(mnemonic).then(seed => Wallet.fromSeed(seed, Networks[network]));\n  }\n\n  /**\n   * Generates a seed from the given mnemonic.\n   * @param String mnemonic\n   * @return {Promise.Buffer} Seed for wallet generation.\n   */\n  static mnemonicToSeed(mnemonic) {\n    return Promise.resolve(bip39.mnemonicToSeed(mnemonic));\n  }\n\n  /**\n   * Finds the hd node thats public key corresponds to the given address.\n   * @param {HDNode} node Start node to\n   * @param {String} address Target address.\n   * @param {Number} maxDepth Max index before algorithm stops.\n   * @return {Promise.HDNode}\n   */\n  static findDeriveNodeByAddress(node, address, maxDepth) {\n    return Wallet.findDeriveIndexByAddressForNode(node, address, maxDepth).then(index => node.derive(index));\n  }\n\n  static findDeriveNodeByPublicKeyForNode(node, pubkey, maxDepth) {\n    return Wallet.findDeriveIndexByPublicKey(node, pubkey, maxDepth).then(index => node.derive(index));\n  }\n\n  /**\n   * Finds the wallets HD index thats public key corresponds to the given address.\n   * @param {String} address\n   * @param {Number} maxDepth\n   * @return {Promise.Number}\n   */\n  findDeriveIndexByAddress(address, maxDepth) {\n    return Wallet.findDeriveIndexByAddressForNode(this.rootnode, address, maxDepth);\n  }\n\n  /**\n   * For the given HD node it finds the derivative index thats corresponds to the given public key.\n   * @param {HDNode} node Start node to\n   * @param {String} pukey Target public key.\n   * @param {Number} maxDepth Max index before algorithm stops.\n   * @return {Promise.HDNode}\n   */\n  static findDeriveIndexByPublicKey(node, pubkey, maxDepth) {\n    return new Promise((resolve, reject) => {\n      let i = 0,\n          done = 0;\n      if (maxDepth == undefined) maxDepth = DEFAULT_KEY_SEARCH_DEPTH;\n\n      while (i < maxDepth && !done) {\n        if (node.derive(i).getPublicKeyBuffer().toString('hex') == pubkey) {\n          done++;\n          resolve(i);\n        }\n\n        i++;\n      }\n\n      if (!done) {\n        reject(Error('ERR_NO_HDNODE_FOR_PUBLICKEY'));\n      }\n    });\n  }\n\n  /**\n   * For the given HD node it finds the derivative index thats public key corresponds to the given address.\n   * @param {HDNode} node Start node to\n   * @param {String} address Target address.\n   * @param {Number} maxDepth Max index before algorithm stops.\n   * @return {Promise.HDNode}\n   */\n  static findDeriveIndexByAddressForNode(node, address, maxDepth) {\n    return new Promise((resolve, reject) => {\n      let i = 0,\n          done = 0;\n      if (maxDepth == undefined) maxDepth = DEFAULT_KEY_SEARCH_DEPTH;\n\n      while (i < maxDepth && !done) {\n        if (node.derive(i).getAddress() == address) {\n          done++;\n          resolve(i);\n        }\n\n        i++;\n      }\n\n      if (!done) {\n        reject(Error('ERR_NO_HDNODE_FOR_ADDRESS'));\n      }\n    });\n  }\n\n  /**\n   * Finds the wallets HD node that corresponds to the given public key.\n   * @param {String} pubkey\n   * @param {Number} maxDepth\n   * @return {Promise.HDNode}\n   */\n  findDeriveNodeByPublicKey(pubkey, maxDepth) {\n    return Wallet.findDeriveNodeByPublicKeyForNode(this.rootnode, pubkey, maxDepth);\n  }\n\n  /**\n   * Finds the wallets HD node thats public key corresponds to the given address.\n   * @param {String} address\n   * @param {Number} maxDepth\n   * @return {Promise.HDNode}\n   */\n  findPublicKeyByAddess(address, maxDepth) {\n    return Wallet.findDeriveNodeByAddress(this.rootnode, address, maxDepth).then(node => node.getPublicKeyBuffer().toString('hex'));\n  }\n\n  static validateMnemonic(mnemonic, wordlist) {\n    return bip39.validateMnemonic(mnemonic, wordlist);\n  }\n  /**\n   * Finds the wallets HD node thats public key corresponds to the given address.\n   * @param {String} address\n   * @param {Number} maxDepth\n   * @return {Promise.HDNode}\n   */\n\n\n  findDeriveNodeByAddess(address, maxDepth) {\n    return Wallet.findDeriveNodeByAddress(this.rootnode, address, maxDepth);\n  }\n\n  static getNodeFromWIF(wif, network = 'mainnet') {\n    return bitcoin.ECPair.fromWIF(wif, Networks[network]);\n  }\n  /**\n   * Gets the address for the given hd index of the wallet.\n   * @param {Number} index\n   * @returns {String}\n   */\n\n\n  getAddress(index) {\n    if (index == undefined) index = 0;\n    return this.rootnode.derive(index).getAddress();\n  }\n\n  /**\n   * Gets the addresses of the wallet.\n   * @param {Number} number number of addresses\n   * @param {Number} start_from index to start from\n   * @returns {Array<String>}\n   */\n  getAddresses(number, start_from) {\n    if (start_from == undefined) start_from = 0;\n    if (number == undefined) number = 10;\n    let addresses = [];\n\n    for (let i = 0; i < number; i++) addresses.push(this.getAddress(i));\n\n    return addresses;\n  }\n\n  /**\n   * Sign the given transaction.\n   * @param {Transaction} transaction\n   * @return{Promise.Transaction} Signed transaction.\n   */\n  sign(transaction, throwWhenUnknown = true) {\n    return Promise.all(transaction.inputs.map((input, index) => {\n      return this.generateInputScript(transaction, input, index, throwWhenUnknown).then(script => {\n        input.script = script;\n        return input;\n      });\n    })).then(inputs => {\n      transaction.inputs = inputs;\n      return transaction;\n    });\n  }\n\n  /**\n   * Sign the given transaction from multisig wallet.\n   * @param {Transaction} transaction\n   * @param {Multisig} multisig Multisignature wallet object\n   * @return{Promise.Transaction} Signed transaction.\n   */\n  signMultisig(transaction, multisig) {\n    return Promise.all(transaction.inputs.map((input, index) => this.generateInputScriptMultisig(transaction, input, index, multisig))).then(input_scripts => Promise.all(input_scripts.map((script, index) => {\n      transaction.inputs[index].script = script;\n    }))).then(() => transaction);\n  }\n\n  getMasterPublicKey() {\n    return this.rootnode.neutered().toBase58();\n  }\n\n  signMessage(address, message, as_buffer = false) {\n    return this.findDeriveNodeByAddess(address).then(node => Message.sign(message, node.keyPair.d.toBuffer(32), node.keyPair.compressed)).then(buffer => as_buffer ? buffer : buffer.toString('hex'));\n  }\n\n  /**\n   * Generate input script (signature).\n   * @param {Transaction} transaction\n   * @param {String} input_address\n   * @param {Number} index\n   * @return {Promise.String}\n   */\n  generateInputScript(transaction, input, index, throwWhenUnknown) {\n    return this.findDeriveNodeByAddess(input.address).then(node => Wallet.generateInputScriptParameters(node, transaction, index)).catch(error => {\n      if (throwWhenUnknown || error.message !== 'ERR_NO_HDNODE_FOR_ADDRESS') throw error;\n      return input.script;\n    });\n  }\n\n  generateInputScriptMultisig(transaction, input, index, multisig) {\n    return this.findDeriveNodeByPublicKey(multisig.s).then(node => Wallet.generateInputScriptParametersMultisig(node, transaction, index, multisig.r));\n  }\n\n  /**\n   * Generate input script (signature) for the transactions input with the given index.\n   * @param {HDNode} node HD node used for signature\n   * @param {Transaction} transaction\n   * @param {Number} index\n   * @return {Promise.String}\n   */\n  static generateInputScriptParameters(hdnode, transaction, index) {\n    return new Promise((resolve, reject) => {\n      if (Script.isP2SH(transaction.inputs[index].previous_output.script)) throw \"Illegal script type P2SH\";\n      let unsigned_tx = transaction.clone().clearInputScripts().encode(index);\n      let script_buffer = Buffer.alloc(4);\n      script_buffer.writeUInt32LE(1, 0);\n      var prepared_buffer = Buffer.concat([unsigned_tx, script_buffer]);\n      var sig_hash = bitcoin.crypto.sha256(bitcoin.crypto.sha256(prepared_buffer));\n      let signature = hdnode.sign(sig_hash).toDER().toString('hex') + '01';\n      let parameters = [Buffer.from(signature, 'hex'), hdnode.getPublicKeyBuffer()]; //Check if the previous output was locked etp\n\n      let lockregex = /^\\[\\ ([a-f0-9]+)\\ \\]\\ numequalverify dup\\ hash160\\ \\[ [a-f0-9]+\\ \\]\\ equalverify\\ checksig$/gi;\n\n      if (transaction.inputs[index].previous_output.script && transaction.inputs[index].previous_output.script.match(lockregex)) {\n        let number = lockregex.exec(transaction.inputs[index].previous_output.script.match(lockregex)[0])[1];\n        parameters.push(Buffer.from(number, 'hex'));\n      }\n\n      resolve(parameters);\n    });\n  }\n\n  static generateInputScriptParametersMultisig(hdnode, transaction, index, redeem) {\n    return new Promise((resolve, reject) => {\n      if (!Script.isP2SH(transaction.inputs[index].previous_output.script)) throw \"Illegal script type. Only P2SH is supported for multisignature signing\";\n      let unsigned_tx = transaction.clone().clearInputScripts();\n      unsigned_tx.inputs[index].redeem = redeem;\n      unsigned_tx = unsigned_tx.encode(index);\n      let script_buffer = Buffer.alloc(4);\n      script_buffer.writeUInt32LE(1, 0);\n      var prepared_buffer = Buffer.concat([unsigned_tx, script_buffer]);\n      var sig_hash = bitcoin.crypto.sha256(bitcoin.crypto.sha256(prepared_buffer));\n      let signature = hdnode.sign(sig_hash).toDER().toString('hex') + '01';\n      let parameters = Script.extractP2SHSignatures(transaction.inputs[index].script);\n      parameters.forEach(s => {\n        if (s == signature) throw \"Signature already included\";\n      });\n      parameters = [signature].concat(parameters);\n      parameters.push(redeem);\n      parameters = parameters.map(p => Buffer.from(p, 'hex'));\n      parameters = [0].concat(parameters);\n      resolve(parameters);\n    });\n  }\n\n}\n\nWallet.wordlists = bip39.wordlists;\nmodule.exports = Wallet;","map":null,"metadata":{},"sourceType":"script"}