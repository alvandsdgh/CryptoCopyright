{"ast":null,"code":"var base58check = require('base58check');\n\nlet bitcoinjs = require('bitcoinjs-lib');\n\nvar crypto = require('crypto');\n\nvar assert = require('assert');\n\nvar Script = require('./script');\n\nvar ripemd160 = require('ripemd160');\n\nvar OPS = require('metaverse-ops');\n\nfunction generate(m, pubKeys) {\n  let script = redeem(m, pubKeys);\n  return {\n    script: script,\n    address: address(script)\n  };\n}\n\nfunction fromRedeem(redeem) {\n  redeem = Buffer.isBuffer(redeem) ? redeem : Buffer.from(redeem, 'hex');\n  var chunks = Script.fromBuffer(redeem).chunks;\n  assert(chunks.pop() == OPS.OP_CHECKMULTISIG, 'Redeem script must check multisig');\n  var k = [];\n  var n = chunks.pop() - OPS.OP_RESERVED;\n\n  for (var i = 0; i < n; i++) {\n    k.push(chunks.pop());\n  }\n\n  k = k.reverse();\n  var m = chunks.pop() - OPS.OP_RESERVED;\n  assert(chunks.length === 0, 'Invalid redeem script');\n  return {\n    m,\n    n,\n    k,\n    r: redeem.toString('hex')\n  };\n}\n\nfunction redeem(m, pubKeys) {\n  return bitcoinjs.script.multisig.output.encode(m, pubKeys.map(key => Buffer.from(key, 'hex')).sort()).toString('hex');\n}\n\n;\n\nfunction address(redeem) {\n  var hash = new ripemd160().update(crypto.createHash('sha256').update(Buffer.from(redeem, 'hex')).digest()).digest('hex').toString('hex');\n  return base58check.encode(hash, '05');\n}\n\n;\n\nfunction getSignatureStatus(transaction, inputIndex, redeem, network, targetPublicKey) {\n  // Extract the existing signatures from the input script\n  var signatures = Script.extractP2SHSignatures(transaction.inputs[inputIndex].script).map(string => bitcoinjs.ECSignature.fromDER(Buffer.from(string.substr(0, string.length - 2), 'hex'))); //Get public keys from redeem script\n\n  var multisigConfig = fromRedeem(redeem); // Calculate the transaction signature hash for the given index \n\n  var unsigned_tx = transaction.clone().clearInputScripts();\n  unsigned_tx.inputs[inputIndex].redeem = redeem;\n  unsigned_tx = unsigned_tx.encode(inputIndex);\n  var prepared_buffer = Buffer.concat([unsigned_tx, Buffer.from('01000000', 'hex')]);\n  var sig_hash = bitcoinjs.crypto.sha256(bitcoinjs.crypto.sha256(prepared_buffer));\n  var targetSigned = false;\n  var numberOfSignatures = 0;\n  var signatureMap = multisigConfig.k.map(pulicKeyBuffer => {\n    var ecPair = bitcoinjs.ECPair.fromPublicKeyBuffer(pulicKeyBuffer, network);\n\n    for (var i = 0; i < signatures.length; i++) {\n      if (ecPair.verify(sig_hash, signatures[i])) {\n        if (targetPublicKey && !targetSigned && pulicKeyBuffer.toString('hex') === targetPublicKey) {\n          targetSigned = true;\n        }\n\n        numberOfSignatures++;\n        return i;\n      }\n    }\n\n    return -1;\n  });\n  var result = {\n    complete: numberOfSignatures >= multisigConfig.m,\n    signatureMap\n  };\n\n  if (targetPublicKey) {\n    result.targetSigned = targetSigned;\n  }\n\n  return result;\n}\n\nfunction isMultisigAddress(address) {\n  return /^3[1-9A-HJ-NP-Za-km-z]{33}$/.test(address);\n}\n\nmodule.exports = {\n  generate,\n  isMultisigAddress,\n  address,\n  publicKeysFromRedeem: fromRedeem,\n  getSignatureStatus\n};","map":null,"metadata":{},"sourceType":"script"}