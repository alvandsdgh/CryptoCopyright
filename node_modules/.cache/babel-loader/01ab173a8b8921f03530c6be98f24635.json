{"ast":null,"code":"'use strict';\n\nconst bufferutils = require('./bufferutils.js'),\n      base58check = require('base58check'),\n      Script = require('./script'),\n      Constants = require('./constants'),\n      OPS = require('metaverse-ops');\n\nclass Encoder {\n  static UInt32LE(number) {\n    var buffer = Buffer.alloc(8);\n    return buffer.slice(0, buffer.writeUInt32LE(number, 0));\n  }\n\n  static UInt8(number) {\n    var buffer = Buffer.alloc(2);\n    return buffer.slice(0, buffer.writeUInt8(number, 0));\n  }\n\n  static decodeTransaction(transaction, rawtx, network) {\n    return fromBuffer(transaction, Buffer.from(rawtx, 'hex'), network);\n  }\n\n  static encodeTransaction(tx, prepare_index) {\n    return Buffer.concat([encodeVersion(tx.version), encodeInputs(tx.inputs, prepare_index), encodeOutputs(tx.outputs), encodeLockTime(tx.lock_time)]);\n  }\n\n}\n/**\n * Encode the version number for the raw transaction.\n * @param {Number} version\n * @returns {Buffer}\n */\n\n\nfunction encodeVersion(version) {\n  var buffer = Buffer.allocUnsafe(4);\n  buffer.writeInt32LE(version, 0);\n  return buffer;\n}\n/**\n * Encode raw transactions inputs\n * @param {Array<input>} inputs\n * @param {Number} add_address_to_previous_output_index (optional) Index of an input thats previous output address should be added (needed for signing).\n * @returns {Buffer}\n * @throws {Error}\n */\n\n\nfunction encodeInputs(inputs, add_address_to_previous_output_index) {\n  //Initialize buffer and offset\n  let offset = 0;\n  var buffer = Buffer.allocUnsafe(100000); //Write number of inputs\n\n  offset += bufferutils.writeVarInt(buffer, inputs.length, offset);\n  inputs.forEach((input, index) => {\n    //Write reversed hash\n    offset += Buffer.from(input.previous_output.hash, 'hex').reverse().copy(buffer, offset); //Index\n\n    offset = buffer.writeUInt32LE(input.previous_output.index, offset);\n\n    if (add_address_to_previous_output_index !== undefined) {\n      if (index == add_address_to_previous_output_index) {\n        let lockregex = /^\\[\\ ([a-f0-9]+)\\ \\]\\ numequalverify dup\\ hash160\\ \\[ [a-f0-9]+\\ \\]\\ equalverify\\ checksig$/gi;\n\n        if (input.previous_output.script && input.previous_output.script.match(lockregex)) {\n          let locktime = lockregex.exec(input.previous_output.script.match(lockregex)[0])[1];\n          offset = writeScriptLockedPayToPubKeyHash(input.previous_output.address, locktime, buffer, offset);\n        } else {\n          if (Script.hasAttenuationModel(input.previous_output.script)) {\n            let params = Script.getAttenuationParams(input.previous_output.script);\n            offset = writeAttenuationScript(params.model, params.hash !== '0000000000000000000000000000000000000000000000000000000000000000' ? params.hash : undefined, params.index >= 0 ? params.index : undefined, input.previous_output.address, buffer, offset);\n          } else {\n            if (Script.isP2SH(input.previous_output.script)) {\n              let script_buffer = Buffer.from(input.redeem, 'hex');\n              offset += bufferutils.writeVarInt(buffer, script_buffer.length, offset);\n              offset += script_buffer.copy(buffer, offset);\n            } else {\n              if (input.previous_output.script) {\n                let script_buffer = Script.fromASM(input.previous_output.script).toBuffer();\n                offset += bufferutils.writeVarInt(buffer, script_buffer.length, offset);\n                offset += script_buffer.copy(buffer, offset);\n              } else {\n                offset = writeScriptPayToPubKeyHash(input.previous_output.address, buffer, offset);\n              }\n            }\n          }\n        }\n      } else {\n        offset = buffer.writeUInt8(0, offset);\n      }\n    } else {\n      //input script\n      let script_buffer = encodeInputScript(input.script);\n      offset += bufferutils.writeVarInt(buffer, script_buffer.length, offset);\n      offset += script_buffer.copy(buffer, offset);\n    }\n\n    offset = buffer.writeUInt32LE(input.sequence, offset);\n  });\n  return buffer.slice(0, offset);\n}\n/**\n * Encode raw transaction ouputs.\n * @param {Array<Output>} outputs\n * @returns {Buffer} Encoded outputs\n * @throws {Error}\n */\n\n\nfunction encodeOutputs(outputs) {\n  //Initialize buffer and offset\n  let offset = 0;\n  var buffer = Buffer.allocUnsafe(1000000); //Write number of inputs\n\n  offset += bufferutils.writeVarInt(buffer, outputs.length, offset);\n  outputs.forEach(output => {\n    //Write value as 8byte integer\n    offset = bufferutils.writeUInt64LE(buffer, output.value, offset); //Output script\n\n    if (output.script_type) {\n      switch (output.script_type) {\n        case 'p2sh':\n          offset = writeScriptPayToScriptHash(output.address, buffer, offset);\n          break;\n\n        case 'pubkeyhash':\n          offset = writeScriptPayToPubKeyHash(output.address, buffer, offset);\n          break;\n\n        case 'op_return':\n          offset = writeScriptOpReturn(buffer, offset);\n          break;\n\n        case 'lock':\n          let locktime_le_string = parseInt(output.locktime).toString(16).replace(/^(.(..)*)$/, \"0$1\").match(/../g).reverse().join(\"\");\n          offset = writeScriptLockedPayToPubKeyHash(output.address, locktime_le_string, buffer, offset);\n          break;\n\n        case 'attenuation':\n          let model = Script.deserializeAttenuationModel(output.attenuation.model);\n          if (output.attenuation.height_delta > 0) model = Script.adjustAttenuationModel(model, output.attenuation.height_delta);\n          offset = writeAttenuationScript(Script.serializeAttenuationModel(model), output.attenuation.from_tx, output.attenuation.from_index, output.address, buffer, offset);\n          break;\n\n        default:\n          throw 'Unknown script type: ' + output.script_type;\n      }\n    } else if (output.script) {\n      let script = Script.fromASM(output.script).buffer;\n      offset += bufferutils.writeVarInt(buffer, script.length, offset);\n      offset += script.copy(buffer, offset);\n    } else {\n      throw 'Neither script not script type present';\n    } // attachment\n\n\n    offset = buffer.writeUInt32LE(output.attachment.version, offset);\n    offset = buffer.writeUInt32LE(output.attachment.type, offset);\n\n    if (output.attachment.version === Constants.ATTACHMENT.VERSION.DID) {\n      offset += encodeString(buffer, output.attachment.to_did, offset);\n      offset += encodeString(buffer, output.attachment.from_did, offset);\n    }\n\n    switch (output.attachment.type) {\n      case Constants.ATTACHMENT.TYPE.ETP_TRANSFER:\n        break;\n\n      case Constants.ATTACHMENT.TYPE.MST:\n        switch (output.attachment.status) {\n          case Constants.MST.STATUS.REGISTER:\n            offset = encodeAttachmentAssetIssue(buffer, offset, output.attachment);\n            break;\n\n          case Constants.MST.STATUS.TRANSFER:\n            offset = encodeAttachmentMSTTransfer(buffer, offset, output.attachment.symbol, output.attachment.quantity);\n            break;\n\n          default:\n            throw Error(\"Asset status unknown\");\n        }\n\n        break;\n\n      case Constants.ATTACHMENT.TYPE.MESSAGE:\n        offset = encodeAttachmentMessage(buffer, offset, output.attachment.message);\n        break;\n\n      case Constants.ATTACHMENT.TYPE.AVATAR:\n        offset = encodeAttachmentDid(buffer, offset, output.attachment);\n        break;\n\n      case Constants.ATTACHMENT.TYPE.CERT:\n        offset = encodeAttachmentCert(buffer, offset, output.attachment);\n        break;\n\n      case Constants.ATTACHMENT.TYPE.MIT:\n        switch (output.attachment.status) {\n          case Constants.MIT.STATUS.REGISTER:\n            offset = encodeAttachmentMITRegister(buffer, offset, output.attachment.symbol, output.attachment.content, output.attachment.address);\n            break;\n\n          case Constants.MIT.STATUS.TRANSFER:\n            offset = encodeAttachmentMITTransfer(buffer, offset, output.attachment.symbol, output.attachment.address);\n            break;\n\n          default:\n            throw Error(\"Asset status unknown\");\n        }\n\n        break;\n\n      default:\n        throw Error(\"What kind of an output is that?!\");\n    }\n  });\n  return buffer.slice(0, offset);\n}\n\nfunction encodeString(buffer, str, offset, encoding = 'utf-8') {\n  var payload = Buffer.from(str, encoding);\n  offset += bufferutils.writeVarInt(buffer, payload.length, offset);\n  return payload.copy(buffer, offset) + 1;\n}\n/**\n * Encode the lock time.\n * @param {Number} lock_time\n * @returns {Buffer}\n */\n\n\nfunction encodeLockTime(lock_time) {\n  var buffer = Buffer.alloc(4);\n  buffer.writeInt32LE(lock_time, 0);\n  return buffer;\n}\n/**\n * Helper function to encode the attachment for a message.\n * @param {Buffer} buffer\n * @param {Number} offset\n * @param {string} message\n * @returns {Number} New offset\n * @throws {Error}\n */\n\n\nfunction encodeAttachmentMessage(buffer, offset, message) {\n  if (message == undefined) throw Error('Specify message');\n  offset += encodeString(buffer, message, offset);\n  return offset;\n}\n\n;\n/**\n * Helper function to encode the attachment for an asset transfer.\n * @param {Buffer} buffer\n * @param {Number} offset\n * @param {String} symbol\n * @param {Number} quantity\n * @returns {Number} New offset\n * @throws {Error}\n */\n\nfunction encodeAttachmentMSTTransfer(buffer, offset, symbol, quantity) {\n  if (symbol == undefined) throw Error('Specify output asset');\n  if (quantity == undefined) throw Error('Specify output quanity');\n  offset = buffer.writeUInt32LE(Constants.MST.STATUS.TRANSFER, offset);\n  offset += encodeString(buffer, symbol, offset);\n  offset = bufferutils.writeUInt64LE(buffer, quantity, offset);\n  return offset;\n}\n\n;\n/**\n * Helper function to encode the attachment for a new did.\n * @param {Buffer} buffer\n * @param {Number} offset\n * @param {Number} attachment_data\n * @returns {Number} New offset\n * @throws {Error}\n */\n\nfunction encodeAttachmentDid(buffer, offset, attachment_data) {\n  offset = buffer.writeUInt32LE(attachment_data.status, offset);\n  offset += encodeString(buffer, attachment_data.symbol, offset);\n  offset += encodeString(buffer, attachment_data.address, offset);\n  return offset;\n}\n\n;\n/**\n * Helper function to encode the attachment for a certificate.\n * @param {Buffer} buffer\n * @param {Number} offset\n * @param {Number} attachment_data\n * @returns {Number} New offset\n * @throws {Error}\n */\n\nfunction encodeAttachmentCert(buffer, offset, attachment_data) {\n  offset += encodeString(buffer, attachment_data.symbol, offset);\n  offset += encodeString(buffer, attachment_data.owner, offset);\n  offset += encodeString(buffer, attachment_data.address, offset);\n  offset = buffer.writeUInt32LE(attachment_data.cert, offset);\n  offset = buffer.writeUInt8(attachment_data.status, offset);\n\n  if (attachment_data.content) {\n    offset += encodeString(buffer, attachment_data.content, offset);\n  }\n\n  return offset;\n}\n\n;\n/**\n * Helper function to encode the attachment for a new asset.\n * @param {Buffer} buffer\n * @param {Number} offset\n * @param {Number} attachment_data\n * @returns {Number} New offset\n * @throws {Error}\n */\n\nfunction encodeAttachmentAssetIssue(buffer, offset, attachment_data) {\n  offset = buffer.writeUInt32LE(attachment_data.status, offset); //Encode symbol\n\n  offset += encodeString(buffer, attachment_data.symbol, offset); //Encode maximum supply\n\n  offset = bufferutils.writeUInt64LE(buffer, attachment_data.max_supply, offset); //Encode precision\n\n  offset = buffer.writeUInt8(attachment_data.precision, offset); //Encode secondary issue threshold\n\n  if (attachment_data.secondaryissue_threshold == -1) attachment_data.secondaryissue_threshold = 127;\n  offset = buffer.writeUInt8(attachment_data.secondaryissue_threshold ? attachment_data.secondaryissue_threshold : 0, offset);\n  offset += buffer.write(\"0000\", offset, 2, 'hex'); //Encode issuer\n\n  offset += encodeString(buffer, attachment_data.issuer, offset); //Encode recipient address\n\n  offset += encodeString(buffer, attachment_data.address, offset); //Encode description\n\n  offset += encodeString(buffer, attachment_data.description, offset);\n  return offset;\n}\n\n;\n/**\n * Helper function to encode the attachment for a new MIT.\n * @param {Buffer} buffer\n * @param {Number} offset\n * @param {String} symbol\n * @param {String} content\n * @param {String} address\n * @returns {Number} New offset\n * @throws {Error}\n */\n\nfunction encodeAttachmentMITRegister(buffer, offset, symbol, content, address) {\n  offset = buffer.writeUInt8(Constants.MIT.STATUS.REGISTER, offset);\n  offset += encodeString(buffer, symbol, offset);\n  offset += encodeString(buffer, address, offset);\n  offset += encodeString(buffer, content, offset);\n  return offset;\n}\n\n;\n/**\n * Helper function to encode the attachment for a new MIT.\n * @param {Buffer} buffer\n * @param {Number} offset\n * @param {String} symbol\n * @param {String} address\n * @returns {Number} New offset\n * @throws {Error}\n */\n\nfunction encodeAttachmentMITTransfer(buffer, offset, symbol, address) {\n  offset = buffer.writeUInt8(Constants.MIT.STATUS.TRANSFER, offset);\n  offset += encodeString(buffer, symbol, offset);\n  offset += encodeString(buffer, address, offset);\n  return offset;\n}\n\n;\n/**\n * Enodes the given input script.\n * @param {String} script_string\n * @returns {Buffer}\n */\n\nfunction encodeInputScript(parameters) {\n  return Script.fromChunks(parameters ? parameters : []).buffer;\n}\n\n;\n/**\n * Write p2sh to the given buffer.\n * @param {String} scripthash For example multisig address\n * @param {Buffer} buffer\n * @param {Number} offset\n * @returns {Number} new offset\n */\n\nfunction writeScriptPayToScriptHash(scripthash, buffer, offset) {\n  offset = buffer.writeUInt8(23, offset); //Script length\n\n  offset = buffer.writeUInt8(OPS.OP_HASH160, offset); //Write previous output address\n\n  offset = buffer.writeUInt8(20, offset); //Address length\n\n  offset += Buffer.from(base58check.decode(scripthash, 'hex').data, 'hex').copy(buffer, offset); //Static transfer stuff\n\n  offset = buffer.writeUInt8(OPS.OP_EQUAL, offset);\n  return offset;\n}\n/**\n * Write p2pkh to the given buffer.\n * @param {String} address\n * @param {Buffer} buffer\n * @param {Number} offset\n * @returns {Number} new offset\n */\n\n\nfunction writeScriptPayToPubKeyHash(address, buffer, offset) {\n  offset = buffer.writeUInt8(25, offset); //Script length\n\n  offset = buffer.writeUInt8(OPS.OP_DUP, offset);\n  offset = buffer.writeUInt8(OPS.OP_HASH160, offset); //Write previous output address\n\n  offset = buffer.writeUInt8(20, offset); //Address length\n\n  offset += Buffer.from(base58check.decode(address, 'hex').data, 'hex').copy(buffer, offset); //Static transfer stuff\n\n  offset = buffer.writeUInt8(OPS.OP_EQUALVERIFY, offset);\n  offset = buffer.writeUInt8(OPS.OP_CHECKSIG, offset);\n  return offset;\n}\n\nfunction writeScriptOpReturn(buffer, offset) {\n  offset = buffer.writeUInt8(1, offset); //Script length\n\n  offset = buffer.writeUInt8(OPS.OP_RETURN, offset);\n  return offset;\n}\n/**\n * Write p2pkh attenuation script to the given buffer.\n * @param {String} attenuation_string\n * @param {String} from_tx\n * @param {number} index\n * @param {String} address\n * @param {Buffer} buffer\n * @param {Number} offset\n * @returns {Number} new offset\n */\n\n\nfunction writeAttenuationScript(attenuation_string, from_tx, from_index, address, buffer, offset) {\n  let attenuation_buffer = Buffer.from(attenuation_string.toString('hex'));\n  offset += bufferutils.writeVarInt(buffer, 26 + attenuation_string.length + 40, offset);\n  offset = buffer.writeUInt8(77, offset);\n  offset = buffer.writeInt16LE(attenuation_string.length, offset);\n  offset += attenuation_buffer.copy(buffer, offset);\n  offset = buffer.writeUInt8(36, offset);\n  let hash = Buffer.from(from_tx != undefined ? from_tx : '0000000000000000000000000000000000000000000000000000000000000000', 'hex').reverse();\n  let index = Buffer.from('ffffffff', 'hex');\n  if (from_index != undefined) index.writeInt32LE(from_index, 0);\n  offset += Buffer.concat([hash, index]).copy(buffer, offset);\n  offset = buffer.writeUInt8(178, offset);\n  offset = buffer.writeUInt8(OPS.OP_DUP, offset);\n  offset = buffer.writeUInt8(OPS.OP_HASH160, offset); //Write previous output address\n\n  offset = buffer.writeUInt8(20, offset); //Address length\n\n  offset += Buffer.from(base58check.decode(address, 'hex').data, 'hex').copy(buffer, offset); //Static transfer stuff\n\n  offset = buffer.writeUInt8(OPS.OP_EQUALVERIFY, offset);\n  offset = buffer.writeUInt8(OPS.OP_CHECKSIG, offset);\n  return offset;\n}\n/**\n * Write locked p2pkh to the given buffer.\n * @param {String} address\n * @param {String} locktime little endian hex\n * @param {Buffer} buffer\n * @param {Number} offset\n * @returns {Number} new offset\n */\n\n\nfunction writeScriptLockedPayToPubKeyHash(address, locktime, buffer, offset) {\n  let locktime_buffer = Buffer.from(locktime, 'hex');\n  offset = buffer.writeUInt8(27 + locktime_buffer.length, offset); //Script length\n\n  offset = buffer.writeUInt8(locktime_buffer.length, offset); //Length of locktime\n\n  offset += locktime_buffer.copy(buffer, offset);\n  offset = buffer.writeUInt8(OPS.OP_NUMEQUALVERIFY, offset);\n  offset = buffer.writeUInt8(OPS.OP_DUP, offset);\n  offset = buffer.writeUInt8(OPS.OP_HASH160, offset); //Write previous output address\n\n  offset = buffer.writeUInt8(20, offset); //Address length\n\n  offset += Buffer.from(base58check.decode(address, 'hex').data, 'hex').copy(buffer, offset);\n  offset = buffer.writeUInt8(OPS.OP_EQUALVERIFY, offset);\n  offset = buffer.writeUInt8(OPS.OP_CHECKSIG, offset);\n  return offset;\n}\n\nfunction fromBuffer(tx, buffer, network) {\n  var offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readUInt8() {\n    offset += 1;\n    return buffer.readUInt8(offset - 1);\n  }\n\n  function readUInt32() {\n    offset += 4;\n    return buffer.readUInt32LE(offset - 4);\n  }\n\n  function readUInt64() {\n    offset += 8;\n    return bufferutils.readUInt64LE(buffer, offset - 8);\n  }\n\n  function readVarInt() {\n    var vi = bufferutils.readVarInt(buffer, offset);\n    offset += vi.size;\n    return vi.number;\n  }\n\n  function readString() {\n    var length = bufferutils.readVarInt(buffer, offset);\n    offset += length.size;\n    return readSlice(length.number).toString();\n  }\n\n  function readScript() {\n    return Script.fromBuffer(readSlice(readVarInt())).toASM();\n  }\n\n  function readAttachment() {\n    let attachment = {};\n    attachment.version = readUInt32();\n    attachment.type = readUInt32();\n\n    if (attachment.version === Constants.ATTACHMENT.VERSION.DID) {\n      attachment.to_did = readString();\n      attachment.from_did = readString();\n    }\n\n    switch (attachment.type) {\n      case Constants.ATTACHMENT.TYPE.ETP_TRANSFER:\n        break;\n\n      case Constants.ATTACHMENT.TYPE.MST:\n        attachment.status = readUInt32();\n\n        switch (attachment.status) {\n          case Constants.MST.STATUS.REGISTER:\n            attachment.symbol = readString();\n            attachment.max_supply = readUInt64();\n            attachment.precision = readUInt8();\n            attachment.secondaryissue_threshold = readUInt8();\n            if (attachment.secondaryissue_threshold == 127) attachment.secondaryissue_threshold = -1;\n\n            if (attachment.secondaryissue_threshold > 127) {\n              attachment.secondaryissue_threshold -= 128;\n              attachment.is_secondaryissue = 1;\n            } else {\n              attachment.is_secondaryissue = 0;\n            }\n\n            offset += 2;\n            attachment.issuer = readString();\n            attachment.address = readString();\n            attachment.description = readString();\n            break;\n\n          case Constants.MST.STATUS.TRANSFER:\n            attachment.symbol = readString();\n            attachment.quantity = readUInt64();\n            break;\n\n          default:\n            throw 'Unknown attachment status: ' + attachment.status;\n        }\n\n        break;\n\n      case Constants.ATTACHMENT.TYPE.MESSAGE:\n        attachment.message = readString();\n        break;\n\n      case Constants.ATTACHMENT.TYPE.AVATAR:\n        attachment.status = readUInt32();\n        attachment.symbol = readString();\n        attachment.address = readString();\n        break;\n\n      case Constants.ATTACHMENT.TYPE.MIT:\n        attachment.status = readUInt8();\n        attachment.symbol = readString();\n        attachment.address = readString();\n\n        if (attachment.status == Constants.MIT.STATUS.REGISTER) {\n          attachment.content = readString();\n        }\n\n        break;\n\n      case Constants.ATTACHMENT.TYPE.CERT:\n        attachment.symbol = readString();\n        attachment.owner = readString();\n        attachment.address = readString();\n        attachment.cert = readUInt32();\n        attachment.status = readUInt8();\n\n        if (certHasContent(attachment.cert)) {\n          attachment.content = readString();\n        }\n\n        break;\n\n      case Constants.ATTACHMENT.TYPE.COINSTAKE:\n        break;\n\n      default:\n        throw 'Unknown attachment type: ' + attachment.type;\n    }\n\n    return attachment;\n  }\n\n  function certHasContent(certType) {\n    switch (certType) {\n      case Constants.CERT.TYPE.MINING:\n        return true;\n    }\n\n    return false;\n  }\n\n  function readGenerationScript() {\n    return new Script(readSlice(readVarInt()), []);\n  }\n\n  tx.version = readUInt32();\n  var input_length = readVarInt();\n\n  for (var i = 0; i < input_length; ++i) {\n    tx.inputs.push({\n      previous_output: {\n        hash: readSlice(32).reverse().toString('hex'),\n        index: readUInt32()\n      },\n      script: readScript(),\n      sequence: readUInt32()\n    });\n  }\n\n  var output_length = readVarInt();\n\n  for (i = 0; i < output_length; ++i) {\n    let output = {\n      value: readUInt64(),\n      script: readScript(),\n      attachment: readAttachment()\n    };\n\n    if (Script.hasAttenuationModel(output.script)) {\n      output.script_type = 'attenuation';\n      output.attenuation = {\n        model: Script.getAttenuationModel(output.script)\n      };\n      output.address = Script.getAddressFromOutputScript(output.script, network);\n    }\n\n    output.address = Script.getAddressFromOutputScript(output.script, network);\n    tx.outputs.push(output);\n  }\n\n  tx.lock_time = readUInt32();\n  return tx;\n}\n\n;\nmodule.exports = Encoder;","map":null,"metadata":{},"sourceType":"script"}