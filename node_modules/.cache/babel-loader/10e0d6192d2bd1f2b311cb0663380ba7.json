{"ast":null,"code":"var bs58check = require('bs58check');\n\nvar createHash = require('create-hash');\n\nvar secp256k1 = require('secp256k1');\n\nvar varuint = require('varuint-bitcoin');\n\nfunction sha256(b) {\n  return createHash('sha256').update(b).digest();\n}\n\nfunction hash256(buffer) {\n  return sha256(sha256(buffer));\n}\n\nfunction hash160(buffer) {\n  return createHash('ripemd160').update(sha256(buffer)).digest();\n}\n\nfunction encodeSignature(signature, recovery, compressed) {\n  if (compressed) recovery += 4;\n  return Buffer.concat([Buffer.alloc(1, recovery + 27), signature]);\n}\n\nfunction decodeSignature(buffer) {\n  if (buffer.length !== 65) throw new Error('Invalid signature length');\n  var flagByte = buffer.readUInt8(0) - 27;\n  if (flagByte > 7) throw new Error('Invalid signature parameter');\n  return {\n    compressed: !!(flagByte & 4),\n    recovery: flagByte & 3,\n    signature: buffer.slice(1)\n  };\n}\n\nfunction size(text) {\n  return Buffer.from(text).length;\n}\n\nfunction magicHash(message, messagePrefix) {\n  messagePrefix = messagePrefix || '\\u0018Metaverse Signed Message:\\n';\n  if (!Buffer.isBuffer(messagePrefix)) messagePrefix = Buffer.from(messagePrefix, 'utf8');\n  var messageVISize = varuint.encodingLength(message.length);\n  var buffer = Buffer.allocUnsafe(messagePrefix.length + messageVISize + message.length);\n  messagePrefix.copy(buffer, 0);\n  varuint.encode(message.length, buffer, messagePrefix.length);\n  buffer.write(message, messagePrefix.length + messageVISize);\n  return hash256(buffer);\n}\n\nfunction sign(message, privateKey, compressed, messagePrefix) {\n  var hash = magicHash(message, messagePrefix);\n  var sigObj = secp256k1.sign(hash, privateKey);\n  return encodeSignature(sigObj.signature, sigObj.recovery, compressed);\n}\n\nfunction verify(message, address, signature, messagePrefix) {\n  if (!Buffer.isBuffer(signature)) signature = Buffer.from(signature, 'hex');\n  var parsed = decodeSignature(signature);\n  var hash = magicHash(message, messagePrefix);\n  var publicKey = secp256k1.recover(hash, parsed.signature, parsed.recovery, parsed.compressed);\n  var actual = hash160(publicKey);\n  var expected = bs58check.decode(address).slice(1);\n  if (!Buffer.isBuffer(expected)) expected = Buffer.from(expected, 'hex');\n  return Buffer.compare(actual, expected) == 0;\n}\n\nmodule.exports = {\n  magicHash: magicHash,\n  sign: sign,\n  size: size,\n  verify: verify\n};","map":null,"metadata":{},"sourceType":"script"}