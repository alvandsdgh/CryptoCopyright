{"ast":null,"code":"const Script = require('./script'),\n      Constants = require('./constants');\n\nclass Output {\n  constructor() {\n    this.address = null;\n    this.attachment = {\n      version: Constants.ATTACHMENT.VERSION.DEFAULT\n    };\n    this.value = 0;\n    this.script_type = \"pubkeyhash\";\n  }\n\n  setTransfer(address, value) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.MESSAGE;\n    this.script_type = \"pubkeyhash\";\n    return this;\n  }\n\n  setMITRegister(address, symbol, content) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.MIT;\n    this.attachment.symbol = symbol;\n    this.attachment.address = address;\n    this.attachment.content = content;\n    this.attachment.status = Constants.MST.STATUS.REGISTER;\n    return this;\n  }\n\n  setMITTransfer(address, symbol) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.MIT;\n    this.attachment.symbol = symbol;\n    this.attachment.address = address;\n    this.attachment.status = Constants.MST.STATUS.TRANSFER;\n    return this;\n  }\n\n  setBurn() {\n    this.script_type = 'op_return';\n    return this;\n  }\n\n  setAssetTransfer(address, symbol, quantity) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.MST;\n    this.attachment.symbol = symbol;\n    this.attachment.quantity = quantity;\n    this.attachment.status = Constants.MST.STATUS.TRANSFER;\n    return this;\n  }\n\n  setAttenuation(attenuation_model, height_delta, from_tx, from_index) {\n    this.attenuation = {\n      model: attenuation_model,\n      height_delta: height_delta,\n      from_tx: from_tx,\n      from_index: from_index\n    };\n    this.script_type = 'attenuation';\n    return this;\n  }\n\n  setAssetIssue(symbol, max_supply, precision, issuer, address, description, secondaryissue_threshold, is_secondaryissue) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.MST;\n    this.attachment.status = Constants.MST.STATUS.REGISTER;\n    this.attachment.symbol = symbol;\n    this.attachment.secondaryissue_threshold = secondaryissue_threshold + (is_secondaryissue || secondaryissue_threshold == -1 ? 128 : 0);\n    this.attachment.max_supply = max_supply;\n    this.attachment.precision = precision;\n    this.attachment.issuer = issuer;\n    this.attachment.address = address;\n    this.attachment.description = description;\n    return this;\n  }\n\n  setTransfer(address, value) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.ETP_TRANSFER;\n    this.value = value;\n    return this;\n  }\n\n  setMessage(address, message) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.MESSAGE;\n    this.attachment.message = message;\n    return this;\n  }\n\n  setP2SH() {\n    this.script_type = \"p2sh\";\n    return this;\n  }\n\n  setDeposit(address, value, locktime) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.ETP_TRANSFER;\n    this.value = value;\n    this.locktime = locktime;\n    this.script_type = \"lock\";\n    return this;\n  }\n\n  setIdentityIssue(address, symbol, did_address) {\n    if (did_address == undefined) did_address = address;\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.AVATAR;\n    this.attachment.symbol = symbol;\n    this.attachment.address = did_address;\n    this.attachment.status = Constants.AVATAR.STATUS.REGISTER;\n    return this;\n  }\n\n  setIdentityTransfer(address, symbol, did_address) {\n    if (did_address == undefined) did_address = address;\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.AVATAR;\n    this.attachment.symbol = symbol;\n    this.attachment.address = did_address;\n    this.attachment.status = Constants.AVATAR.STATUS.TRANSFER;\n    return this;\n  }\n\n  setIdentityTransfer(address, value) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.ETP_TRANSFER;\n    this.value = value;\n    return this;\n  }\n\n  setCert(symbol, owner, address, cert, status, content) {\n    this.address = address;\n    this.attachment.type = Constants.ATTACHMENT.TYPE.CERT;\n    this.attachment.owner = owner;\n    this.attachment.symbol = symbol;\n    this.attachment.content = content;\n\n    switch (typeof cert == 'string' ? cert.toLowerCase() : cert) {\n      case 'domain':\n        this.attachment.cert = Constants.CERT.TYPE.DOMAIN;\n        break;\n\n      case 'issue':\n        this.attachment.cert = Constants.CERT.TYPE.ISSUE;\n        break;\n\n      case 'naming':\n        this.attachment.cert = Constants.CERT.TYPE.NAMING;\n        break;\n\n      case 'mining':\n        this.attachment.cert = Constants.CERT.TYPE.MINING;\n        break;\n\n      default:\n        throw 'ERR_UNKNOWN_CERT';\n    }\n\n    switch (typeof status == 'string' ? status.toLowerCase() : status) {\n      case 'issue':\n        this.attachment.status = Constants.CERT.STATUS.ISSUE;\n        break;\n\n      case 'transfer':\n        this.attachment.status = Constants.CERT.STATUS.TRANSFER;\n        break;\n\n      case 'autoissue':\n        this.attachment.status = Constants.CERT.STATUS.AUTOISSUE;\n        break;\n\n      default:\n        if (typeof status == 'number') this.attachment.status = status;else this.attachment.status = Constants.CERT.STATUS.DEFAULT;\n    }\n\n    this.attachment.address = address;\n    return this;\n  }\n\n  specifyDid(to_did, from_did) {\n    this.attachment.version = Constants.ATTACHMENT.VERSION.DID;\n    this.attachment.to_did = to_did;\n    this.attachment.from_did = from_did;\n    return this;\n  }\n\n  /**\n   * Filters the given outputs by the given inputs. Return the unspent transaction outputs.\n   * @param {Array<Output>} outputs\n   * @param {Array<Input>} inputs\n   * @return {Promise.Array<Output>}\n   */\n  static filterUtxo(outputs, inputs) {\n    return new Promise((resolve, reject) => {\n      let ins = JSON.parse(JSON.stringify(inputs));\n      let utxo = [];\n\n      if (outputs.length) {\n        outputs.forEach((output, oindex) => {\n          let spent = 0;\n          if (ins.length) ins.forEach((input, index) => {\n            if (!spent && input.belong_tx_id == output.tx_id && input.output_index == output.index) {\n              spent = 1;\n            }\n          });\n          if (!spent) utxo.push(output);\n        });\n      }\n\n      resolve(utxo);\n    });\n  }\n\n  /**\n   * Generates an array of unspent outputs calculated by the given transactions and addresses.\n   * @param {Array<Transaction>} transactions\n   * @param {Array<string>} addresses\n   */\n  static calculateUtxo(txs, addresses) {\n    return new Promise(resolve => {\n      let list = {};\n      txs.forEach((tx, index) => {\n        tx.inputs.forEach(input => {\n          list[input.previous_output.hash + '-' + input.previous_output.index] = 'spent';\n        });\n        tx.outputs.forEach(output => {\n          if (addresses.indexOf(output.address) !== -1 && list[tx.hash + '-' + output.index] !== 'spent') {\n            output.locked_until = output.locked_height_range ? tx.height + output.locked_height_range : 0;\n            delete output['locked_height_range'];\n            output.hash = tx.hash;\n            list[tx.hash + '-' + output.index] = output;\n          }\n        });\n      });\n      let utxo = [];\n      Object.values(list).forEach(item => {\n        if (item !== 'spent') utxo.push(item);\n      });\n      resolve(utxo);\n    });\n  }\n  /**\n   * Generates an array of outputs that can be used to perform a transaction with the given requirements.\n   * @param {Array<Output>} utxo\n   * @param {Object} target definition\n   */\n\n\n  static findUtxo(utxo, originalTarget, current_height, fee = Constants.FEE.DEFAULT, useLargestEtpUtxo = false) {\n    const target = JSON.parse(JSON.stringify(originalTarget));\n    return new Promise((resolve, reject) => {\n      //Add fee\n      if (target[\"ETP\"]) target.ETP += fee;else target.ETP = fee;\n      var change = JSON.parse(JSON.stringify(target));\n      var lockedAssetChange = [];\n      var list = [];\n\n      if (useLargestEtpUtxo) {\n        utxo = utxo.sort(function (a, b) {\n          return b.value - a.value;\n        });\n      }\n\n      utxo.forEach(output => {\n        if (!targetComplete(change)) {\n          // prepare output locking information\n          if (output.locked_until === undefined && output.locked_height_range !== undefined && output.height !== undefined) {\n            output.locked_until = output.height + output.locked_height_range;\n          }\n\n          if (output.previous_output === undefined) {\n            output.previous_output = {\n              hash: output.tx,\n              index: output.index,\n              script: output.script\n            };\n          }\n\n          if (output.hash === undefined && output.tx !== undefined) {\n            output.hash = output.tx;\n          }\n\n          switch (output.attachment.type) {\n            case 'etp':\n              if (current_height == undefined || output.locked_until <= current_height && change.ETP > 0 && output.value > 0) {\n                change.ETP -= output.value;\n                list.push(output);\n              }\n\n              break;\n\n            case 'asset-transfer':\n            case 'asset-issue':\n              if (change.ETP > 0 && output.value > 0 || change[output.attachment.symbol] > 0 && Output.assetSpendable(output, output.height, current_height) > 0) {\n                change.ETP -= output.value;\n                if (change[output.attachment.symbol] == undefined) change[output.attachment.symbol] = 0;\n                change[output.attachment.symbol] -= Output.assetSpendable(output, output.height, current_height);\n\n                if (output.attachment.quantity > Output.assetSpendable(output, output.height, current_height)) {\n                  let lockChange = {\n                    symbol: output.attachment.symbol,\n                    quantity: output.attachment.quantity - Output.assetSpendable(output, output.height, current_height),\n                    attenuation_model: Script.getAttenuationModel(output.script),\n                    hash: output.hash,\n                    delta: current_height - output.height,\n                    index: output.index\n                  };\n                  lockedAssetChange.push(lockChange);\n                }\n\n                list.push(output);\n              }\n\n              break;\n          }\n        }\n      });\n      if (!targetComplete(change)) throw Error('ERR_INSUFFICIENT_UTXO');\n\n      if (list.length > Constants.UTXO.MAX_COUNT) {\n        if (!useLargestEtpUtxo) {\n          return this.findUtxo(utxo, originalTarget, current_height, fee, true).then(result => resolve(result)).catch(error => reject(Error(error.message)));\n        } else {\n          reject(Error('ERR_TOO_MANY_INPUTS'));\n        }\n      }\n\n      resolve({\n        utxo: list,\n        change: change,\n        lockedAssetChange: lockedAssetChange,\n        selected: target\n      });\n    });\n  }\n\n  /**\n   * Filters the given outputs with the given filter.\n   * @param {Array<Output>} outputs\n   * @param {Object} filter\n   * @return {Array<Output>}\n   */\n  static filter(outputs, filter) {\n    return outputs.filter(output => {\n      if (filter.type !== undefined) {\n        if (!Array.isArray(filter.type) && filter.type !== output.attachment.type) return false;else if (Array.isArray(filter.type) && filter.type.indexOf(output.attachment.type) == -1) return false;\n      }\n\n      if (filter.symbol !== undefined) {\n        if (!Array.isArray(filter.symbol) && filter.symbol !== output.attachment.symbol) return false;else if (Array.isArray(filter.symbol) && filter.type.indexOf(output.attachment.symbol) == -1) return false;\n      }\n\n      if (filter.address !== undefined) {\n        if (!Array.isArray(filter.address) && filter.address !== output.address) return false;else if (Array.isArray(filter.address) && filter.address.indexOf(output.address) == -1) return false;\n      }\n\n      return true;\n    });\n  }\n\n  static assetSpendable(output, tx_height, current_height) {\n    switch (output.attachment.type) {\n      case 'asset-transfer':\n      case 'asset-issue':\n        break;\n\n      default:\n        throw Error('ERR_TYPE_NOT_APPLICABLE');\n    }\n\n    if (Script.hasAttenuationModel(output.script)) {\n      let model = Script.deserializeAttenuationModel(Script.getAttenuationModel(output.script));\n      let locked = 0;\n      let step_target = model.LH;\n\n      switch (model.TYPE) {\n        case 1:\n          for (let period = model.PN; period < model.UN; period++) {\n            if (period != model.PN) step_target += model.LP / model.UN;\n            if (tx_height + step_target > current_height) locked += model.LQ / model.UN;\n          }\n\n          return output.attachment.quantity - locked;\n\n        case 2:\n        case 3:\n          for (let period = model.PN; period < model.UC.length; period++) {\n            if (period != model.PN) step_target += model.UC[period];\n            if (tx_height + step_target > current_height) locked += model.UQ[period];\n          }\n\n          return output.attachment.quantity - locked;\n      }\n    } else {\n      return output.attachment.quantity;\n    }\n  }\n\n}\n/**\n * Helper function to check a target object if there are no more positive values.\n * @param {Object} targets\n * @returns {Boolean}\n */\n\n\nfunction targetComplete(target) {\n  let complete = true;\n  Object.values(target).forEach(value => {\n    if (value > 0) complete = false;\n  });\n  return complete;\n}\n\nmodule.exports = Output;","map":null,"metadata":{},"sourceType":"script"}