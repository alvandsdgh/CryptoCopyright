{"ast":null,"code":"var assert = require('assert'),\n    bufferutils = require('./bufferutils'),\n    base58check = require('base58check'),\n    OPS = require('metaverse-ops');\n\nconst OP_INT_BASE = OPS.OP_1 - 1;\n\nlet Script = function (buffer, chunks) {\n  this.buffer = buffer;\n  this.chunks = chunks;\n};\n\nScript.fromBuffer = function (buffer) {\n  var chunks = [];\n  var i = 0;\n\n  while (i < buffer.length) {\n    var opcode = buffer.readUInt8(i); // data chunk\n\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      var d = bufferutils.readPushDataInt(buffer, i); // did reading a pushDataInt fail? return non-chunked script\n\n      if (d === null) return new Script(buffer, []);\n      i += d.size; // attempt to read too much data?\n\n      if (i + d.number > buffer.length) return new Script(buffer, []);\n      var data = buffer.slice(i, i + d.number);\n      i += d.number;\n      chunks.push(data); // opcode\n    } else {\n      chunks.push(opcode);\n      i++;\n    }\n  }\n\n  return new Script(buffer, chunks);\n};\n\nScript.getAddressFromOutputScript = function (script, network = 'mainnet') {\n  let prefix = null;\n\n  switch (Script.getType(script)) {\n    case 'attenuation':\n    case 'p2pkh':\n    case 'lock':\n      prefix = network == 'mainnet' ? '32' : '7F';\n      break;\n\n    case 'p2sh':\n      prefix = '05';\n      break;\n\n    default:\n      return undefined;\n  }\n\n  let address = / ([0-9a-fA-F]{40}) /.exec(script);\n  return address ? base58check.encode(address[address.length - 1], prefix, 'hex') : undefined;\n};\n\nScript.getType = function (script) {\n  if (Script.isP2PKH(script)) {\n    return 'p2pkh';\n  } else if (Script.isP2SH(script)) {\n    return 'p2sh';\n  } else if (Script.isOpReturn(script)) {\n    return 'op_return';\n  } else if (Script.isStakeLock(script)) {\n    return 'stakelock';\n  } else if (Script.isLock(script)) {\n    return 'lock';\n  } else if (Script.hasAttenuationModel(script)) {\n    return 'attenuation';\n  }\n\n  return 'custom';\n};\n\nScript.isLock = function (script) {\n  return /^\\[ ([0-9a-f]+) \\] (?:op_numequalverify|numequalverify) (?:op_dup|dup) (?:op_hash160|hash160) \\[ ([0-9a-f]{40}) \\] (?:op_equalverify|equalverify) (?:op_checksig|checksig)$/i.test(script);\n};\n\nScript.isOpReturn = function (script) {\n  return /(?:op_return|return)/i.test(script);\n};\n\nScript.isStakeLock = function (script) {\n  return /^\\[ ([0-9a-f]+) \\] (?:op_checksequenceverify|checksequenceverify) (?:op_drop|drop) (?:op_dup|dup) (?:op_hash160|hash160) \\[ ([0-9a-f]{40}) \\] (?:op_equalverify|equalverify) (?:op_checksig|checksig)$/i.test(script);\n};\n\nScript.isP2SH = function (script) {\n  return /^(?:op\\_hash160|hash160) \\[ ([0-9a-f]{40}) \\] (?:op\\_equal|equal)$/i.test(script);\n};\n\nScript.isP2PKH = function (script) {\n  return /^(?:op_dup|dup) (?:op_hash160|hash160) \\[ ([0-9a-f]{40}) \\] (?:op_equalverify|equalverify) (?:op_checksig|checksig)$/i.test(script);\n};\n\nScript.fromChunks = function (chunks) {\n  var bufferSize = chunks.reduce(function (accum, chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      return accum + bufferutils.pushDataSize(chunk.length) + chunk.length;\n    } // opcode\n\n\n    return accum + 1;\n  }, 0.0);\n  var buffer = Buffer.alloc(bufferSize);\n  var offset = 0;\n  chunks.forEach(function (chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      offset += bufferutils.writePushDataInt(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length; // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  assert.equal(offset, buffer.length, 'Could not decode chunks');\n  return new Script(buffer, chunks);\n};\n\nScript.fromHex = function (hex) {\n  return Script.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nScript.EMPTY = Script.fromChunks([]);\n\nScript.prototype.toBuffer = function () {\n  return this.buffer;\n};\n\nScript.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.getType = function () {\n  return Script.getType(this.toASM());\n};\n\nScript.prototype.toASM = function () {\n  var reverseOps = [];\n\n  for (var op in OPS) {\n    var code = OPS[op];\n    reverseOps[code] = op;\n  }\n\n  return this.chunks.map(function (chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      return '[ ' + chunk.toString('hex') + ' ]'; // opcode\n    } else {\n      return reverseOps[chunk];\n    }\n  }).join(' ');\n};\n\nScript.prototype.getLockLength = function () {\n  if (['lock', 'stakelock'].includes(this.getType())) {\n    if (!Buffer.isBuffer(this.chunks[0])) throw 'Illegal lock length';\n    if (this.chunks[0].length > 4) return -1;\n    let buffer = new Buffer.from('00000000', 'hex');\n    this.chunks[0].copy(buffer, 0);\n    return buffer.readInt32LE(0);\n  }\n\n  return 0;\n};\n\nScript.fullnodeFormat = function (script) {\n  let level = 0;\n  script = script.split(' ').map(token => {\n    if (token == '[') {\n      level++;\n    } else if (token == ']') {\n      level--;\n    } else if (level == 0) {\n      return 'OP_' + token.toUpperCase();\n    }\n\n    return token;\n  }).join(' ');\n  return script;\n};\n\nScript.fromFullnode = function (script) {\n  return Script.fromASM(Script.fullnodeFormat(script));\n};\n\nfunction fromASM(asm) {\n  let level = 0;\n  let chunks = [];\n  asm.split(' ').forEach(chunkStr => {\n    if (chunkStr == '[') level++;else if (chunkStr == ']') level--;else {\n      if (level == 0) {\n        chunkStr = chunkStr.toUpperCase();\n        if (OPS[chunkStr]) chunks.push(OPS[chunkStr]);else if (OPS['OP_' + chunkStr]) chunks.push(OPS['OP_' + chunkStr]);else throw 'Unknown OP code';\n      } else {\n        chunks.push(Buffer.from(chunkStr, 'hex'));\n      }\n    }\n  });\n  return Script.fromChunks(chunks);\n}\n\nScript.fromASM = function (script) {\n  script = script.replace(/\\s+/g, ' ');\n  return fromASM(script);\n};\n\nScript.hasAttenuationModel = function (script) {\n  let regex = /^\\[\\ ([a-f0-9]+)\\ \\]\\ \\[\\ ([a-f0-9]+)\\ \\]\\ (checkattenuationverify|op_checkattenuationverify)\\ (dup|op_dup)\\ (hash160|op_hash160)\\ \\[ [a-f0-9]+\\ \\]\\ (equalverify|op_equalverify)\\ (checksig|op_checksig)$/gi;\n  return regex.test(script);\n};\n\nScript.getAttenuationModel = function (script) {\n  let regex = /^\\[\\ ([a-f0-9]+)\\ \\]\\ \\[\\ ([a-f0-9]+)\\ \\]\\ (checkattenuationverify|op_checkattenuationverify)\\ (dup|op_dup)\\ (hash160|op_hash160)\\ \\[ [a-f0-9]+\\ \\]\\ (equalverify|op_equalverify)\\ (checksig|op_checksig)$/gi;\n\n  if (Script.hasAttenuationModel(script)) {\n    let b = regex.exec(script.match(regex)[0])[1];\n    return Buffer.from(b, 'hex').toString();\n  }\n\n  return null;\n};\n\nScript.getAttenuationParams = function (script) {\n  let regex = /^\\[\\ ([a-f0-9]+)\\ \\]\\ \\[\\ ([a-f0-9]+)\\ \\]\\ checkattenuationverify\\ dup\\ hash160\\ \\[ [a-f0-9]+\\ \\]\\ equalverify\\ checksig$/gi;\n\n  if (Script.hasAttenuationModel(script)) {\n    let p = regex.exec(script.match(regex)[0]);\n    return {\n      model: Buffer.from(p[1], 'hex').toString(),\n      hash: Buffer.from(p[2].substr(0, 64), 'hex').reverse().toString('hex'),\n      index: Buffer.from(p[2].substr(64, 8), 'hex').readInt32LE(0)\n    };\n  }\n\n  return null;\n};\n\nScript.makeAttenuationScript = function (attenuation_string, from_tx, from_index, to_address) {\n  let hash = Buffer.from(from_tx || '0000000000000000000000000000000000000000000000000000000000000000', 'hex').reverse();\n  let index = Buffer.from('ffffffff', 'hex').writeInt32LE(from_index || 4294967295);\n  ;\n  return \"[ \".concat(attenuation_string, \" ] [ \").concat(Buffer.concat([hash, index]).toString('hex'), \" ]  checkattenuationverify dup hash160 [ \").concat(to_address, \" ] equalverify checksig\");\n};\n\nScript.deserializeAttenuationModel = function (string) {\n  let tmp = {};\n  string.split(';').forEach(part => {\n    let t = part.split('=');\n\n    if (t.length == 2) {\n      if (t[1].toString().indexOf(',') !== -1) tmp[t[0]] = t[1].toString().split(',').map(e => parseInt(e));else tmp[t[0]] = parseInt(t[1]);\n    }\n  });\n\n  switch (tmp.TYPE) {\n    case 1:\n    case 2:\n    case 3:\n      return tmp;\n      break;\n\n    default:\n      throw Error('ERR_DESERIALIZE_ATTENUATION_MODEL');\n  }\n};\n\nScript.serializeAttenuationModel = function (model) {\n  let result = '';\n  Object.keys(model).forEach(key => {\n    result += key + '=' + (Array.isArray(model[key]) ? model[key].join(',') : model[key]) + ';';\n  });\n  return result.substr(0, result.length - 1);\n};\n\nScript.extractP2SHSignatures = script => {\n  let regex = /(?:\\[ ([a-f0-9]+) \\])/gi;\n  let signatures = [];\n  var xArray;\n\n  while (xArray = regex.exec(script)) signatures.push(xArray[1]);\n\n  if (signatures.length > 1) return signatures.splice(0, signatures.length - 1);\n  return [];\n};\n\nScript.extractP2SHRedeem = script => {\n  let regex = /(?:\\[ ([a-f0-9]+) \\])/gi;\n  let signatures = [];\n  var xArray;\n\n  while (xArray = regex.exec(script)) signatures.push(xArray[1]);\n\n  if (signatures.length) return signatures[signatures.length - 1];\n  return null;\n};\n\nScript.combineP2SHSignatures = (signatures, redeem) => {\n  let script = \"zero \";\n  signatures.forEach(s => script += \"[ \" + s + \" ]\");\n  script += \" [ \" + redeem + \" ]\";\n  return script;\n};\n\nScript.adjustAttenuationModel = function (model, height_delta) {\n  if (!height_delta > 0) {\n    return model;\n  }\n\n  let blocks_left = null;\n\n  switch (model.TYPE) {\n    case 1:\n      let period_size = model.LP / model.UN;\n      blocks_left = model.LH;\n\n      for (let period = model.PN; period < model.UN; period++) {\n        if (blocks_left >= height_delta) {\n          model.LH = blocks_left - height_delta;\n          model.PN = period;\n          return model;\n        }\n\n        blocks_left += period_size;\n      }\n\n      throw Error('ERR_ADJUST_ATTENUATION_MODEL');\n      break;\n\n    case 2:\n    case 3:\n      blocks_left = model.LH;\n\n      for (let period = model.PN; period < model.UC.length; period++) {\n        if (blocks_left >= height_delta) {\n          model.LH = blocks_left - height_delta;\n          model.PN = period;\n          return model;\n        }\n\n        blocks_left += model.UC[period + 1];\n      }\n\n      throw Error('ERR_ADJUST_ATTENUATION_MODEL');\n      break;\n\n    default:\n      throw Error('ERR_ADJUST_ATTENUATION_MODEL_UNKNOWN_TYPE');\n  }\n};\n\nmodule.exports = Script;","map":null,"metadata":{},"sourceType":"script"}