{"ast":null,"code":"'use strict';\n\nvar Transaction = require('./transaction'),\n    Constants = require('./constants'),\n    Output = require('./output.js');\n\nclass TransactionBuilder {\n  /**\n   * Generates a send (etp and or asset) transaction with the given utxos as inputs, assets and the change.\n   * @param {Array<Output>} utxo Inputs for the transaction\n   * @param {String} recipient_address Recipient address\n   * @param {Object} target Definition of assets to send\n   * @param {String} etp_change_address ETP change address\n   * @param {Object} change Definition of change assets\n   * @param {String} asset_change_address Asset change address\n   */\n  static send(utxo, recipient_address, recipient_avatar, target, etp_change_address, change, locked_asset_change, fee = Constants.FEE.DEFAULT, messages = [], asset_change_address = etp_change_address) {\n    return new Promise((resolve, reject) => {\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      });\n      if (messages == undefined) messages = [];\n      messages.forEach(message => tx.addMessage(recipient_address, message)); //add the target outputs to the recipient\n\n      Object.keys(target).forEach(symbol => target[symbol] ? tx.addOutput(recipient_address, symbol, target[symbol], recipient_avatar) : null);\n      if (target.ETP) etpcheck -= target.ETP; //add the change outputs\n\n      Object.keys(change).forEach(symbol => {\n        if (change[symbol] !== 0) tx.addOutput(symbol.toLowerCase() === 'etp' ? etp_change_address : asset_change_address, symbol, -change[symbol]);\n      });\n      if (locked_asset_change != undefined) locked_asset_change.forEach(change => tx.addLockedAssetOutput(etp_change_address, undefined, change.symbol, change.quantity, change.attenuation_model, change.delta, change.hash, change.index));\n      if (change.ETP) etpcheck += change.ETP;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates a send more (etp and or asset) transaction with the given utxos as inputs, assets and the change.\n   * @param {Array<Output>} utxo Inputs for the transaction\n   * @param {String} recipients Recipients [ { address: \"xxx\", \"target\": { \"ETP\": 123, \"MST\": { \"SDG\": 18 } }, \"avatar\": \"EricGu\", \"attenuation_model\": \"TYPE=1;LQ=9000;LP=60000;UN=3\" } ]\n   * @param {String} change_address Change address\n   * @param {Object} change Definition of change assets\n   * @param {Array<Object>} locked_asset_change Definition of locked asset changes\n   * @param {Number} fee Transaction fee\n   * @param {Array<String>} messages Messages to add to the transaction\n   */\n  static sendMore(utxo, recipients, change_address, change, locked_asset_change, fee = Constants.FEE.DEFAULT, messages = []) {\n    return new Promise((resolve, reject) => {\n      if (recipients == undefined || !recipients.length) throw Error('ERR_NO_RECIPIENTS');\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      });\n      if (messages == undefined) messages = [];\n      messages.forEach(message => tx.addMessage(utxo[0].address, message)); //add the target outputs to the recipients\n\n      recipients.forEach(recipient => {\n        if (recipient.target.ETP) {\n          tx.addETPOutput(recipient.address, recipient.target.ETP, recipient.avatar);\n          etpcheck -= recipient.target.ETP;\n        }\n\n        if (recipient.target.MST) {\n          Object.keys(recipient.target.MST).forEach(symbol => {\n            if (recipient.attenuation_model) {\n              tx.addLockedAssetOutput(recipient.address, recipient.avatar, symbol, recipient.target.MST[symbol], recipient.attenuation_model, 0);\n            } else {\n              tx.addMSTOutput(recipient.address, symbol, recipient.target.MST[symbol], recipient.avatar);\n            }\n          });\n        }\n      }); //add the change outputs\n\n      Object.keys(change).forEach(symbol => {\n        if (change[symbol] !== 0) tx.addOutput(change_address, symbol, -change[symbol]);\n      });\n      if (locked_asset_change != undefined) locked_asset_change.forEach(change => tx.addLockedAssetOutput(change_address, undefined, change.symbol, change.quantity, change.attenuation_model, change.delta, change.hash, change.index));\n      if (change.ETP) etpcheck += change.ETP;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates a send (etp and or asset) transaction with the given utxos as inputs, assets and the change.\n   * @param {Array<Output>} utxo Inputs for the transaction\n   * @param {String} recipient_address Recipient address\n   * @param {Object} target Definition of assets to send\n   * @param {String} change_address Change address\n   * @param {Object} change Definition of change assets\n   */\n  static sendSwap(utxo, recipient_address, recipient_avatar, target, change_address, change, locked_asset_change, fee = Constants.FEE.DEFAULT, network, messages = [], swap_fee = Constants.FEE.SWAP_FEE) {\n    return new Promise((resolve, reject) => {\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      });\n      if (messages == undefined) messages = [];\n      messages.forEach(message => tx.addMessage(recipient_address, message)); //add the target outputs to the recipient\n\n      Object.keys(target).forEach(symbol => target[symbol] ? tx.addOutput(recipient_address, symbol, target[symbol], recipient_avatar) : null);\n      if (target.ETP) etpcheck -= target.ETP; //add the change outputs\n\n      Object.keys(change).forEach(symbol => {\n        if (change[symbol] !== 0) tx.addOutput(change_address, symbol, -change[symbol]);\n      });\n      if (locked_asset_change != undefined) locked_asset_change.forEach(change => tx.addLockedAssetOutput(change_address, undefined, change.symbol, change.quantity, change.attenuation_model, change.delta, change.hash, change.index));\n      if (change.ETP) etpcheck += change.ETP;\n      tx.addETPOutput(Constants.CELEBRITIES.BOUNTY[network].address, swap_fee, Constants.CELEBRITIES.BOUNTY[network].symbol);\n      etpcheck -= swap_fee;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates a send asset transaction with attenuation using the given utxos as inputs, assets and the change.\n   */\n  static sendLockedAsset(utxo, recipient_address, recipient_avatar, symbol, quantity, attenuation_model, change_address, change, locked_asset_change, fee = Constants.FEE.DEFAULT, messages = []) {\n    return new Promise((resolve, reject) => {\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      });\n      if (messages == undefined) messages = [];\n      messages.forEach(message => tx.addMessage(recipient_address, message)); //add the target outputs to the recipient\n\n      tx.addLockedAssetOutput(recipient_address, recipient_avatar, symbol, quantity, attenuation_model, 0); //add the change outputs\n\n      Object.keys(change).forEach(symbol => {\n        if (change[symbol] !== 0) tx.addOutput(change_address, symbol, -change[symbol]);\n      });\n      if (locked_asset_change != undefined) locked_asset_change.forEach(change => tx.addLockedAssetOutput(change_address, undefined, change.symbol, change.quantity, change.attenuation_model, change.delta, change.hash, change.index));\n      if (change.ETP) etpcheck += change.ETP;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates a send more (etp and or asset) transaction with the given utxos as inputs, assets and the change.\n   * @param {Array<Output>} utxo Inputs for the transaction\n   * @param {String} recipients Recipients [ { address: \"xxx\", \"target\": { \"ETP\": 123, \"MST\": { \"SDG\": 18 } }, \"avatar\": \"EricGu\" } ]\n   * @param {String} change_address Change address\n   * @param {Object} change Definition of change assets\n   * @param {Array<Object>} locked_asset_change Definition of locked asset changes\n   * @param {Number} fee Transaction fee\n   * @param {Array<String>} messages Messages to add to the transaction\n   */\n  static sendMoreLockedAsset(utxo, recipients, attenuation_model, change_address, change, locked_asset_change, fee = Constants.FEE.DEFAULT, messages = []) {\n    return new Promise((resolve, reject) => {\n      if (recipients == undefined || !recipients.length) throw Error('ERR_NO_RECIPIENTS');\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      });\n      if (messages == undefined) messages = [];\n      messages.forEach(message => tx.addMessage(utxo[0].address, message)); //add the target outputs to the recipients\n\n      recipients.forEach(recipient => {\n        if (recipient.target.ETP) {\n          tx.addETPOutput(recipient.address, recipient.target.ETP, recipient.avatar);\n          etpcheck -= recipient.target.ETP;\n        }\n\n        if (recipient.target.MST) {\n          Object.keys(recipient.target.MST).forEach(symbol => {\n            tx.addLockedAssetOutput(recipient_address, recipient_avatar, symbol, quantity, attenuation_model, 0);\n          });\n        }\n      }); //add the change outputs\n\n      Object.keys(change).forEach(symbol => {\n        if (change[symbol] !== 0) tx.addOutput(change_address, symbol, -change[symbol]);\n      });\n      if (locked_asset_change != undefined) locked_asset_change.forEach(change => tx.addLockedAssetOutput(change_address, undefined, change.symbol, change.quantity, change.attenuation_model, change.delta, change.hash, change.index));\n      if (change.ETP) etpcheck += change.ETP;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates an etp deposit transaction.\n   * \n   * @deprecated ETP deposit has been deactivated by supernova hardfork\n   * \n   * @param {Array<Output>} utxo Inputs for the transaction\n   * @param {String} recipient_address Recipient address\n   * @param {Number} quantity Quantity of ETP to deposit (in bits)\n   * @param {Number} duration Number of blocks to freeze\n   * @param {String} change_address Change address\n   * @param {Object} change Definition of change assets\n   * @param {Number} fee Optional fee definition (default 10000 bits)\n   * @param {Array<String>} messages Optional array of string messages\n   */\n  static deposit(utxo, recipient_address, quantity, duration, change_address, change, fee = Constants.FEE.DEFAULT, network = 'mainnet', messages = []) {\n    return new Promise((resolve, reject) => {\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      }); //add lock output to the recipient\n\n      tx.addLockOutput(recipient_address, quantity, duration, network);\n      if (messages == undefined) messages = [];\n      messages.forEach(message => tx.addMessage(utxo[0].address, message));\n      etpcheck -= quantity; //add the change outputs\n\n      Object.keys(change).forEach(symbol => tx.addOutput(change_address, symbol, -change[symbol]));\n      if (change.ETP) etpcheck += change.ETP;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates a create avatar transaction.\n   * @param {Array<Output>} utxo Inputs for the transaction\n   * @param {String} avatar_address Recipient address\n   * @param {String} symbol Symbol of avatar\n   * @param {String} change_address Change address\n   * @param {Object} change Definition of change assets\n   */\n  static issueDid(utxo, avatar_address, symbol, change_address, change, bounty_fee, network = 'mainnet', messages = []) {\n    return new Promise((resolve, reject) => {\n      //Set fee\n      var fee = Constants.FEE.AVATAR_REGISTER;\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      }); //add avatar output to the avatar address\n\n      tx.addDidIssueOutput(avatar_address, symbol, avatar_address);\n      messages.forEach(message => tx.addMessage(utxo[0].address, message)); //add the change outputs\n\n      Object.keys(change).forEach(symbol => tx.addOutput(change_address, symbol, -change[symbol]));\n      if (change.ETP) etpcheck += change.ETP;\n\n      if (bounty_fee && bounty_fee > 0) {\n        tx.addETPOutput(Constants.CELEBRITIES.BOUNTY[network].address, bounty_fee, Constants.CELEBRITIES.BOUNTY[network].symbol);\n      }\n\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates a create MIT transaction.\n   * @param {Array<Output>} utxo Inputs for the transaction\n   * @param {String} recipient_address Recipient address\n   * @param {String} symbol Symbol of MIT\n   * @param {String} content Content of MIT\n   * @param {String} change_address Change address\n   * @param {Object} change Definition of change assets\n   * @param {Number} fee Optional fee definition (default 10000 bits)\n   */\n  static registerMIT(utxo, recipient_address, issuer_avatar, symbol, content, change_address, change, fee = Constants.FEE.DEFAULT) {\n    return new Promise((resolve, reject) => {\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      });\n      tx.addMITRegisterOutput(recipient_address, symbol, content).specifyDid(issuer_avatar, issuer_avatar); //add the change outputs\n\n      Object.keys(change).forEach(symbol => tx.addOutput(change_address, symbol, -change[symbol]));\n      if (change.ETP) etpcheck += change.ETP;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates a transfer MIT transaction.\n   * @param {Array<Output>} utxo Inputs for the transaction\n   * @param {String} recipient_address Recipient address\n   * @param {String} symbol Symbol of MIT\n   * @param {String} change_address Change address\n   * @param {Object} change Definition of change assets\n   * @param {Number} fee Optional fee definition (default 10000 bits)\n   */\n  static transferMIT(utxo, sender_avatar, recipient_address, recipient_avatar, symbol, change_address, change, fee = Constants.FEE.DEFAULT) {\n    return new Promise((resolve, reject) => {\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxo.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      });\n      tx.addMITTransferOutput(recipient_address, symbol).specifyDid(recipient_avatar, sender_avatar); //add the change outputs\n\n      Object.keys(change).forEach(symbol => tx.addOutput(change_address, symbol, -change[symbol]));\n      if (change.ETP) etpcheck += change.ETP;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  /**\n   * Generates an asset issue transaction.\n   * @param {Array<Output>} inputs Inputs for the transaction\n   * @param {String} recipient_address Recipient address\n   * @param {String} symbol Symbol of the new asset\n   * @param {Number} max_supply The maximum supply of the asset\n   * @param {Number} precision The number of decimal places\n   * @param {String} issuer Public issuer name\n   * @param {String} description Public description\n   * @param {Number} secondaryissue_threshold -1: no limitation; 0: no secondaryissue; 1..100 threshold user has to hold to be able to do secondary issue\n   * @param {Boolean} is_secondaryissue indication if this output is a secondary issue of an existing asset\n   * @param {String} change_address Change address\n   * @param {Object} change Definition of change assets\n   * @param {Boolean} issue_domain indication if the toplevel domain certificate should be included as an output\n   * @param {Number} fee Optional fee definition (default 10000 bits)\n   */\n  static issueAsset(inputs, recipient_address, symbol, max_supply, precision, issuer, description, secondaryissue_threshold, is_secondaryissue, change_address, change, issue_domain, bounty_fee, network = 'mainnet', attenuation_model = null, mining_model = undefined) {\n    return new Promise((resolve, reject) => {\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //reissue used certs\n\n      let certs = []; //add inputs\n\n      inputs.forEach(input => {\n        if (input.value) etpcheck += input.value;\n        tx.addInput(input.address, input.hash, input.index, input.script);\n\n        if (input.attachment && input.attachment.type == 'asset-cert') {\n          switch (input.attachment.cert) {\n            case 'domain':\n            case 'issue':\n            case 'naming':\n              certs.push(input);\n              break;\n\n            default:\n              console.error('Unknown cert type: ' + input.attachment.cert);\n              throw 'ERR_UNKNOWN_CERT';\n          }\n        }\n      }); //add lock output to the recipient\n\n      let issue_output = tx.addAssetIssueOutput(symbol, max_supply, precision, issuer, recipient_address, description, secondaryissue_threshold, is_secondaryissue).specifyDid(issuer, issuer);\n      if (attenuation_model) issue_output.setAttenuation(attenuation_model, 0); //add certificate to secondaryissue if necessary\n\n      if (secondaryissue_threshold !== 0) tx.addCertOutput(symbol, issuer, recipient_address, 'issue', 'autoissue').specifyDid(issuer, issuer); //reissue used certs\n\n      certs.forEach(cert => {\n        tx.addCertOutput(cert.attachment.symbol, cert.attachment.owner, cert.address, cert.attachment.cert).specifyDid(cert.attachment.to_did, cert.attachment.from_did);\n      }); //add toplevel domain certificate if wanted\n\n      if (issue_domain) tx.addCertOutput(symbol.split(\".\")[0], issuer, recipient_address, 'domain', 'autoissue').specifyDid(issuer, issuer);\n      if (mining_model) tx.addCertOutput(symbol, issuer, recipient_address, 'mining', 'autoissue', mining_model).specifyDid(issuer, issuer); //add the change outputs\n\n      Object.keys(change).forEach(symbol => tx.addOutput(change_address, symbol, -change[symbol]));\n      if (change.ETP) etpcheck += change.ETP;\n\n      if (bounty_fee && bounty_fee > 0) {\n        tx.addETPOutput(Constants.CELEBRITIES.BOUNTY[network].address, bounty_fee, Constants.CELEBRITIES.BOUNTY[network].symbol);\n      }\n\n      if (is_secondaryissue && etpcheck !== Constants.FEE.DEFAULT) throw Error('ERR_FEE_CHECK_FAILED');else if (!is_secondaryissue && etpcheck !== Constants.FEE.MST_REGISTER) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n  static burn(utxos, target, burn_avatar, etp_change_address, change, locked_asset_change, messages = [], asset_change_address = etp_change_address, fee = Constants.FEE.DEFAULT) {\n    return new Promise(resolve => {\n      var etpcheck = 0; //create new transaction\n\n      let tx = new Transaction(); //add inputs\n\n      utxos.forEach(output => {\n        if (output.value) etpcheck += output.value;\n        tx.addInput(output.address, output.hash, output.index, output.script);\n      });\n      if (messages == undefined) messages = [];\n      messages.forEach(message => tx.addMessage(utxos[0].address, message)); //add the target outputs to the recipient\n\n      Object.keys(target).forEach(symbol => target[symbol] ? tx.addOutput(\"\", symbol, target[symbol], burn_avatar).setBurn() : null);\n      if (target.ETP) etpcheck -= target.ETP; //add the change outputs\n\n      Object.keys(change).forEach(symbol => {\n        if (change[symbol] !== 0) tx.addOutput(symbol.toLowerCase() === 'etp' ? etp_change_address : asset_change_address, symbol, -change[symbol]);\n      });\n      if (locked_asset_change != undefined) locked_asset_change.forEach(change => tx.addLockedAssetOutput(etp_change_address, undefined, change.symbol, change.quantity, change.attenuation_model, change.delta, change.hash, change.index));\n      if (change.ETP) etpcheck += change.ETP;\n      if (etpcheck !== fee) throw Error('ERR_FEE_CHECK_FAILED');\n      resolve(tx);\n    });\n  }\n\n}\n\nmodule.exports = TransactionBuilder;","map":null,"metadata":{},"sourceType":"script"}